{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"System Variables","text":"<ul> <li>SYSTEM</li> <li>APPLICATION</li> <li>DEPLOYABLE_UNIT</li> <li>SERVICE_VERSION</li> <li>ENVIRONMENT (Production, Development)</li> </ul>"},{"location":"#bugs","title":"Bugs","text":"<ul> <li>Does not create nested data classes, only first layer</li> </ul>"},{"location":"extensions/configuration/config/","title":"Config","text":"<p>Configuration</p> <p>This module handles the reading of configfiles and the creation of a config object. It looks for the files appconfig.yaml, appconfig.Production.yaml and secrets.yaml. If the same key is available in more than one file it follows the same hierarchy as the order of the just mentioned files.</p> <p>Construct config object Reads configuration files and constructs a dataclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Directory containing configuration files (default is current working directory).</p> <code>cwd()</code> <p>Returns:</p> Type Description <code>Any</code> <p>Dataclass instance constructed from the combined configuration data.</p> Source code in <code>extensions/configuration/config.py</code> <pre><code>def read_configs_to_dataclass(path: Path = Path.cwd()) -&gt; Any:\n    \"\"\"Construct config object\n    Reads configuration files and constructs a dataclass instance.\n\n    Parameters\n    ----------\n    path : Path, optional\n        Directory containing configuration files (default is current working directory).\n\n    Returns\n    -------\n    Any\n        Dataclass instance constructed from the combined configuration data.\n    \"\"\"\n\n    config = read_configs(path)\n    appconfig = make_dataclass_from_config(config)\n    return appconfig\n</code></pre> <p>Read Configs Reads and merges YAML configuration files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Directory containing configuration files (default is current working directory).</p> <code>cwd()</code> <p>Returns:</p> Type Description <code>dict</code> <p>Combined configuration data as a dictionary.</p> Source code in <code>extensions/configuration/config.py</code> <pre><code>def read_configs(\n        path: Path = Path.cwd(),\n) -&gt; dict:\n    \"\"\" Read Configs\n    Reads and merges YAML configuration files.\n\n    Parameters\n    ----------\n    path : Path, optional\n        Directory containing configuration files (default is current working directory).\n\n    Returns\n    -------\n    dict\n        Combined configuration data as a dictionary.\n    \"\"\"\n    config_data = {}\n\n    for file_name in FILE_NAMES:\n        file_path = path / file_name\n\n        if file_path.is_file():\n            with open(file_path, 'r') as file:\n                config_data.update(yaml.safe_load(file))\n\n    return config_data\n</code></pre> <p>Dynamically creates a dataclass from a nested dictionary configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Nested dictionary configuration.</p> required <code>class_name</code> <code>str</code> <p>Name for the top-level dataclass (default is 'AppConfig').</p> <code>'AppConfig'</code> <p>Returns:</p> Type Description <code>type</code> <p>Dynamically generated dataclass type based on the configuration.</p> Source code in <code>extensions/configuration/config.py</code> <pre><code>def make_dataclass_from_config(config: dict, class_name: str = 'AppConfig') -&gt; type:\n    \"\"\"\n    Dynamically creates a dataclass from a nested dictionary configuration.\n\n    Parameters\n    ----------\n    config : dict\n        Nested dictionary configuration.\n    class_name : str, optional\n        Name for the top-level dataclass (default is 'AppConfig').\n\n    Returns\n    -------\n    type\n        Dynamically generated dataclass type based on the configuration.\n    \"\"\"\n    fields_list = []\n\n\n    for key, value in config.items():\n        if isinstance(value, dict):\n            nested_class_name = key.capitalize() + \"Data\"\n            nested_dataclass = make_dataclass_from_config(value, nested_class_name)\n            fields_list.append((key, Union[Any]))\n        else:\n            fields_list.append((key, Any))\n\n    return make_dataclass(class_name, fields_list)(**config)\n</code></pre>"},{"location":"extensions/configuration/config/#extensions.configuration.config.make_dataclass_from_config","title":"<code>make_dataclass_from_config(config, class_name='AppConfig')</code>","text":"<p>Dynamically creates a dataclass from a nested dictionary configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Nested dictionary configuration.</p> required <code>class_name</code> <code>str</code> <p>Name for the top-level dataclass (default is 'AppConfig').</p> <code>'AppConfig'</code> <p>Returns:</p> Type Description <code>type</code> <p>Dynamically generated dataclass type based on the configuration.</p> Source code in <code>extensions/configuration/config.py</code> <pre><code>def make_dataclass_from_config(config: dict, class_name: str = 'AppConfig') -&gt; type:\n    \"\"\"\n    Dynamically creates a dataclass from a nested dictionary configuration.\n\n    Parameters\n    ----------\n    config : dict\n        Nested dictionary configuration.\n    class_name : str, optional\n        Name for the top-level dataclass (default is 'AppConfig').\n\n    Returns\n    -------\n    type\n        Dynamically generated dataclass type based on the configuration.\n    \"\"\"\n    fields_list = []\n\n\n    for key, value in config.items():\n        if isinstance(value, dict):\n            nested_class_name = key.capitalize() + \"Data\"\n            nested_dataclass = make_dataclass_from_config(value, nested_class_name)\n            fields_list.append((key, Union[Any]))\n        else:\n            fields_list.append((key, Any))\n\n    return make_dataclass(class_name, fields_list)(**config)\n</code></pre>"},{"location":"extensions/configuration/config/#extensions.configuration.config.read_configs","title":"<code>read_configs(path=Path.cwd())</code>","text":"<p>Read Configs Reads and merges YAML configuration files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Directory containing configuration files (default is current working directory).</p> <code>cwd()</code> <p>Returns:</p> Type Description <code>dict</code> <p>Combined configuration data as a dictionary.</p> Source code in <code>extensions/configuration/config.py</code> <pre><code>def read_configs(\n        path: Path = Path.cwd(),\n) -&gt; dict:\n    \"\"\" Read Configs\n    Reads and merges YAML configuration files.\n\n    Parameters\n    ----------\n    path : Path, optional\n        Directory containing configuration files (default is current working directory).\n\n    Returns\n    -------\n    dict\n        Combined configuration data as a dictionary.\n    \"\"\"\n    config_data = {}\n\n    for file_name in FILE_NAMES:\n        file_path = path / file_name\n\n        if file_path.is_file():\n            with open(file_path, 'r') as file:\n                config_data.update(yaml.safe_load(file))\n\n    return config_data\n</code></pre>"},{"location":"extensions/configuration/config/#extensions.configuration.config.read_configs_to_dataclass","title":"<code>read_configs_to_dataclass(path=Path.cwd())</code>","text":"<p>Construct config object Reads configuration files and constructs a dataclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Directory containing configuration files (default is current working directory).</p> <code>cwd()</code> <p>Returns:</p> Type Description <code>Any</code> <p>Dataclass instance constructed from the combined configuration data.</p> Source code in <code>extensions/configuration/config.py</code> <pre><code>def read_configs_to_dataclass(path: Path = Path.cwd()) -&gt; Any:\n    \"\"\"Construct config object\n    Reads configuration files and constructs a dataclass instance.\n\n    Parameters\n    ----------\n    path : Path, optional\n        Directory containing configuration files (default is current working directory).\n\n    Returns\n    -------\n    Any\n        Dataclass instance constructed from the combined configuration data.\n    \"\"\"\n\n    config = read_configs(path)\n    appconfig = make_dataclass_from_config(config)\n    return appconfig\n</code></pre>"},{"location":"extensions/configuration/hosting_environment/","title":"Hosting environment","text":"Source code in <code>extensions/configuration/hosting_environment.py</code> <pre><code>def is_production():\n\n    return _environment == PRODUCTION\n</code></pre>"},{"location":"extensions/configuration/service/","title":"Service","text":"Source code in <code>extensions/configuration/service.py</code> <pre><code>def environment():\n    return _environment\n</code></pre> Source code in <code>extensions/configuration/service.py</code> <pre><code>def hostname():\n    return _hostname\n</code></pre> Source code in <code>extensions/configuration/service.py</code> <pre><code>def service_instance():\n    return _instance\n</code></pre> Source code in <code>extensions/configuration/service.py</code> <pre><code>def process_id():\n    return _process_id\n</code></pre> Source code in <code>extensions/configuration/service.py</code> <pre><code>def service_namespace():\n    return f'{_system}.{_application}'\n</code></pre> Source code in <code>extensions/configuration/service.py</code> <pre><code>def service_name():\n    return f'{service_namespace()}.{_deployable_unit}'\n</code></pre> Source code in <code>extensions/configuration/service.py</code> <pre><code>def service_version():\n    return _service_version\n</code></pre> Source code in <code>extensions/configuration/service.py</code> <pre><code>def set_defaults(\n        system=None,\n        application=None,\n        deployable_unit=None,\n        version=None\n):\n    global _system, _application, _deployable_unit, _service_version\n\n    if system is not None:\n        _system = system\n\n    if application is not None:\n        _application = application\n\n    if deployable_unit is not None:\n        _deployable_unit = deployable_unit\n\n    if version is not None:\n        _service_version = version\n</code></pre>"},{"location":"tests/test_configuration/","title":"Test configuration","text":"Source code in <code>tests/test_configuration.py</code> <pre><code>@pytest.fixture\ndef test_config(tmp_path):\n    # Prepare a temporary directory with test YAML files\n    config_path = tmp_path / 'test_configs'\n    config_path.mkdir()\n\n    yaml_data = \"\"\"\n    key1: value1\n    key2:\n        nested_key1: nested_value1\n        nested_key2: nested_value2\n    \"\"\"\n\n    for file_name in ['secrets.yaml', 'appconfig.yaml']:\n        with open(config_path / file_name, 'w') as file:\n            file.write(yaml_data)\n\n    return config_path\n</code></pre> Source code in <code>tests/test_configuration.py</code> <pre><code>def test_read_configs_to_dataclass(test_config):\n    appconfig = read_configs_to_dataclass(test_config)\n\n    # Ensure that the dataclass is created successfully\n    assert appconfig is not None\n\n    # You may add more specific assertions based on your dataclass structure\n    # For example, check if specific fields are present or have expected values\n    assert hasattr(appconfig, 'key1')\n    assert hasattr(appconfig, 'key2')\n</code></pre>"},{"location":"tests/test_set_defaults/","title":"Test set defaults","text":"Source code in <code>tests/test_set_defaults.py</code> <pre><code>@pytest.fixture\ndef setup_defaults():\n    from extensions.configuration import set_defaults, service_namespace, service_name\n    # This fixture sets up the default values before each test.\n    set_defaults(system='default_system', application='default_application', deployable_unit='default_unit',\n                 version='1.0')\n    return set_defaults, service_namespace, service_name\n</code></pre> Source code in <code>tests/test_set_defaults.py</code> <pre><code>def test_set_defaults_with_values(setup_defaults):\n    set_defaults, service_namespace, service_name = setup_defaults\n    # Test set_defaults with specific values\n    set_defaults(system='new_system', application='new_application', deployable_unit='new_unit', version='2.0')\n\n    assert service_namespace() == 'new_system.new_application'\n    assert service_name() == 'new_system.new_application.new_unit'\n</code></pre> Source code in <code>tests/test_set_defaults.py</code> <pre><code>def test_set_defaults_with_defaults(setup_defaults):\n    set_defaults, service_namespace, service_name = setup_defaults\n\n    set_defaults()\n\n    assert service_namespace() == 'default_system.default_application'\n    assert service_name() == 'default_system.default_application.default_unit'\n</code></pre> Source code in <code>tests/test_set_defaults.py</code> <pre><code>def test_set_defaults_with_partial_values(setup_defaults):\n    set_defaults, service_namespace, service_name = setup_defaults\n    set_defaults(application='partial_application', version='3.0')\n\n    assert service_namespace() == 'default_system.partial_application'\n    assert service_name() == 'default_system.partial_application.default_unit'\n</code></pre>"}]}